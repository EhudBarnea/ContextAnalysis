from attach_det_windows_to_gt import *
import matplotlib.pyplot as plt


def eval_detections(label, data, fix_types=list(), plot_fig=False, ovt=0.5):
    # data - dict generated by one of the 'read_data...py' files
    # fix_types - types of FPs to "fix" (assume they are not a mistake)
    # plot_fig - show pr curve
    # ovt - overlap threshold for detections to be considered correct

    overlap_threshold = ovt

    all_set_fp = []
    all_set_tp = []
    all_set_score = []
    all_set_dets = []
    # go over the test images
    num_gt_object = 0  # the total number of objects in the test set

    for img_id in data['imgs'].keys():
        objects = data['objects_pi'][img_id]
        detections = data['dets_pi'][img_id]

        # keep only object and detections of the query label (and dont_care objects)
        detections = [d for d in detections if d['label'] == label]
        objects = [o for o in objects if o['label'] == label or o['dont_care']]

        # get correct detections
        det_correct = attach_det_windows_to_gt(detections, objects, overlap_threshold)

        score = [d['conf'] for d in detections]

        # ignore dont_cares and fixed FPs
        dont_care_dets = det_correct[:, 2]
        for ft in fix_types:
            dont_care_dets = np.logical_or(dont_care_dets, det_correct[:, 3] == ft)

        det_correct = det_correct[np.logical_not(dont_care_dets), :]
        score = [score[xid] for xid, x in enumerate(dont_care_dets) if not x]
        detections = [detections[xid] for xid, x in enumerate(dont_care_dets) if not x]

        # summarize
        tp = det_correct[:, 0]
        tp = np.array(tp)  # to avoid warnings (tp is already an np array)
        fp = 1 - tp
        num_objects = sum(not o['dont_care'] for o in objects)

        # add these to the information over the whole image set
        all_set_tp += tp.tolist()
        all_set_fp += fp.tolist()
        all_set_score += score
        all_set_dets += detections
        num_gt_object += num_objects

    # sort detections by decreasing score across the whole set
    sorted_id = np.argsort(-np.array(all_set_score))
    all_set_tp = list_part(all_set_tp, sorted_id)
    all_set_fp = list_part(all_set_fp, sorted_id)
    # all_set_score = list_part(all_set_score, sorted_id)
    # all_set_dets = list_part(all_set_dets, sorted_id)

    # compute precision / recall
    # corrects = all_set_tp
    all_set_fp = np.cumsum(all_set_fp)
    all_set_tp = np.cumsum(all_set_tp)
    rec = all_set_tp / num_gt_object
    prec = np.divide(all_set_tp, (all_set_tp + all_set_fp))

    # compute average precision
    ap = 0
    p_all = []
    rec_points = np.arange(0, 1.01, 0.01)
    for t in rec_points:
        tmp = prec[rec >= t]
        if len(tmp) == 0:
            p = 0
        else:
            p = max(tmp)
        ap += p / len(rec_points)
        p_all.append(p)

    ap_str = "{0:.3f}".format(ap)
    # print(ap)
    # print(ap_str)

    if plot_fig:
        plt.plot(rec_points, p_all)
        plt.title(label + ': mAP=' + ap_str)
        plt.xlabel('recall')
        plt.ylabel('precision')
        plt.grid(True)
        plt.xlim(0, 1)
        plt.ylim(0, 1)
        # plt.show()
    return ap


def list_part(lst, indices):
    return [lst[i] for i in indices]
